import React, { createContext, useContext, useState, useEffect } from 'react';
import { database } from './firebase';
import { ref, set, get, onValue } from 'firebase/database';
import { generateQuestions } from './services/groqService';

const AppContext = createContext();

export const useApp = () => {
  const context = useContext(AppContext);
  if (!context) {
    throw new Error('useApp must be used within AppProvider');
  }
  return context;
};

// Fallback questions if LLM generation fails
const FALLBACK_QUESTIONS = [
  { id: 1, type: 'long_form', text: 'what is your earliest childhood memory?' },
  { id: 2, type: 'long_form', text: 'if you could have dinner with anyone dead or alive, who would it be?' },
  { id: 3, type: 'yes_no', text: 'do you believe in love at first sight?' },
  { id: 4, type: 'multiple_choice', text: 'how do you prefer to spend your free time?', options: ['reading or learning', 'being active or outdoors', 'socializing with friends', 'relaxing at home'] },
];

const CURRENT_USER_CACHE_KEY = 'jandle_current_user';

export const AppProvider = ({ children }) => {
  // Initialize currentUser from localStorage if available
  const [currentUser, setCurrentUser] = useState(() => {
    try {
      const cachedUser = localStorage.getItem(CURRENT_USER_CACHE_KEY);
      return (cachedUser === 'josh' || cachedUser === 'nini') ? cachedUser : null;
    } catch (error) {
      console.error('Error reading from localStorage:', error);
      return null;
    }
  });

  const [currentPage, setCurrentPage] = useState(() => {
    // If we have a cached user, go to landing page, otherwise go to select
    try {
      const cachedUser = localStorage.getItem(CURRENT_USER_CACHE_KEY);
      return (cachedUser === 'josh' || cachedUser === 'nini') ? 'landing' : 'select';
    } catch (error) {
      return 'select';
    }
  }); // 'select', 'landing', 'questions', 'inbox', 'answers', 'birthday-puzzle', 'birthday-card'

  // Questions pool - dynamically generated by LLM
  const [questionsPool, setQuestionsPool] = useState([]);
  const [questionsLoading, setQuestionsLoading] = useState(true);
  const [isGeneratingMore, setIsGeneratingMore] = useState(false);
  const [initialLoadComplete, setInitialLoadComplete] = useState(false);

  // Track current question index for each user
  const [questionIndex, setQuestionIndex] = useState({ josh: 0, nini: 0 });

  // Inbox: questions answered by the other user that this user needs to answer
  // Format: { josh: [{questionId, questionText, otherUserAnswer}], nini: [...] }
  const [inbox, setInbox] = useState({ josh: [], nini: [] });

  // Answers: completed question pairs with chat threads
  // Format: { josh: [{questionId, questionText, joshAnswer, niniAnswer, messages: []}], nini: [...] }
  const [answers, setAnswers] = useState({ josh: [], nini: [] });

  // Viewed status: tracks what each user has viewed
  // Format: { josh: { questionId: { lastViewed: timestamp, lastMessageCount: number } }, nini: {...} }
  const [viewedStatus, setViewedStatus] = useState({ josh: {}, nini: {} });

  // Generate questions on mount using LLM and reset indices
  useEffect(() => {
    const loadQuestions = async () => {
      try {
        console.log('Generating fresh questions with Groq LLM...');

        await set(ref(database, 'questionIndex'), { josh: 0, nini: 0 });
        console.log('Reset question indices to 0');

        // Generate 10 fresh questions for each new session
        const generatedQuestions = await generateQuestions(10);
        setQuestionsPool(generatedQuestions);
        console.log(`Successfully generated ${generatedQuestions.length} questions`);
      } catch (error) {
        console.error('Failed to generate questions with LLM, using fallback questions:', error);
        setQuestionsPool(FALLBACK_QUESTIONS);
      } finally {
        setQuestionsLoading(false);
        setInitialLoadComplete(true);
      }
    };

    loadQuestions();
  }, []);

  // Monitor question pool and generate more when running low
  useEffect(() => {
    const generateMoreQuestions = async () => {
      // Don't generate if we're already generating, still loading initial questions, or initial load not complete
      if (isGeneratingMore || questionsLoading || !initialLoadComplete) {
        return;
      }

      // Safety check: ensure we have questions and questionIndex
      if (questionsPool.length === 0) {
        return;
      }

      // Find the highest question index across both users
      // Safety check: ensure questionIndex has both user properties
      if (!questionIndex || questionIndex.josh === undefined || questionIndex.nini === undefined) {
        return;
      }
      const maxIndex = Math.max(questionIndex.josh, questionIndex.nini);

      // Only generate more if we have fewer than 8 questions remaining
      const remainingQuestions = questionsPool.length - maxIndex;

      if (remainingQuestions < 8) {
        setIsGeneratingMore(true);
        try {
          console.log(`Running low on questions (${remainingQuestions} remaining), generating more...`);
          const newQuestions = await generateQuestions(10);
          setQuestionsPool(prevPool => {
            const updatedPool = [...prevPool, ...newQuestions];
            console.log(`Added ${newQuestions.length} new questions. Pool now has ${updatedPool.length} questions`);
            return updatedPool;
          });
        } catch (error) {
          console.error('Failed to generate more questions:', error);
        } finally {
          setIsGeneratingMore(false);
        }
      }
    };

    generateMoreQuestions();
  }, [questionIndex.josh, questionIndex.nini, initialLoadComplete, questionsPool.length, isGeneratingMore, questionsLoading]);

  // Initialize Firebase data and set up listeners
  useEffect(() => {
    const initializeData = async () => {
      try {
        // Initialize default data structure if it doesn't exist
        const dataRef = ref(database, '/');
        const snapshot = await get(dataRef);

        if (!snapshot.exists()) {
          await set(dataRef, {
            questionIndex: { josh: 0, nini: 0 },
            inbox: { josh: [], nini: [] },
            answers: { josh: [], nini: [] },
            viewedStatus: { josh: {}, nini: {} }
          });
        }
      } catch (error) {
        console.error('Error initializing Firebase data:', error);
      }
    };

    initializeData();

    // Set up real-time listeners for data changes
    const questionIndexRef = ref(database, 'questionIndex');
    const inboxRef = ref(database, 'inbox');
    const answersRef = ref(database, 'answers');
    const viewedStatusRef = ref(database, 'viewedStatus');

    const unsubscribeQuestionIndex = onValue(questionIndexRef, (snapshot) => {
      if (snapshot.exists()) {
        setQuestionIndex(snapshot.val());
      }
    });

    const unsubscribeInbox = onValue(inboxRef, (snapshot) => {
      if (snapshot.exists()) {
        const inboxData = snapshot.val();
        // Ensure inbox values are arrays (Firebase stores empty arrays as null)
        setInbox({
          josh: inboxData.josh || [],
          nini: inboxData.nini || []
        });
      }
    });

    const unsubscribeAnswers = onValue(answersRef, (snapshot) => {
      if (snapshot.exists()) {
        const answersData = snapshot.val();
        // Ensure all answer objects have a messages array
        const normalizedAnswers = {
          josh: (answersData.josh || []).map(answer => ({
            ...answer,
            messages: answer.messages || []
          })),
          nini: (answersData.nini || []).map(answer => ({
            ...answer,
            messages: answer.messages || []
          }))
        };
        setAnswers(normalizedAnswers);
      }
    });

    const unsubscribeViewedStatus = onValue(viewedStatusRef, (snapshot) => {
      if (snapshot.exists()) {
        setViewedStatus(snapshot.val());
      } else {
        // Initialize viewedStatus if it doesn't exist in Firebase
        setViewedStatus({ josh: {}, nini: {} });
      }
    });

    // Cleanup listeners on unmount
    return () => {
      unsubscribeQuestionIndex();
      unsubscribeInbox();
      unsubscribeAnswers();
      unsubscribeViewedStatus();
    };
  }, []);

  const selectUser = (user) => {
    try {
      // Save user selection to localStorage for persistence across reloads
      localStorage.setItem(CURRENT_USER_CACHE_KEY, user);
    } catch (error) {
      console.error('Error saving to localStorage:', error);
    }
    setCurrentUser(user);
    setCurrentPage('landing');
  };

  const switchPage = (page) => {
    setCurrentPage(page);
  };

  const startApp = () => {
    // Called from landing page when user clicks continue
    // Check if we should show birthday content
    const { getCurrentTheme, THEMES } = require('./utils/themeUtils');
    const currentTheme = getCurrentTheme();

    // Check if birthday card has been viewed this year
    const BIRTHDAY_CARD_VIEWED_KEY = 'jandle_birthday_card_viewed_2024';
    const hasViewedBirthdayCard = localStorage.getItem(BIRTHDAY_CARD_VIEWED_KEY) === 'true';

    if (currentTheme === THEMES.BIRTHDAY && !hasViewedBirthdayCard && currentUser === 'nini') {
      // Show birthday puzzle for Nini if she hasn't seen the card yet
      setCurrentPage('birthday-puzzle');
    } else {
      setCurrentPage('questions');
    }
  };

  const answerQuestion = async (questionId, questionText, answer, questionType, questionData) => {
    const otherUser = currentUser === 'josh' ? 'nini' : 'josh';

    try {
      // Add to other user's inbox in Firebase with question type data
      // Only include optional properties if they exist (Firebase doesn't allow undefined values)
      const newInboxItem = {
        questionId,
        questionText,
        questionType: questionType || 'long_form',
        otherUserAnswer: answer,
        answeredBy: currentUser
      };

      // Conditionally add optional properties only if they're defined
      if (questionData?.options) {
        newInboxItem.questionOptions = questionData.options;
      }
      if (questionData?.items) {
        newInboxItem.questionItems = questionData.items;
      }
      if (questionData?.scenario) {
        newInboxItem.questionScenario = questionData.scenario;
      }

      // Firebase stores empty arrays as null, so we need to handle that
      const otherUserInbox = [...(inbox[otherUser] || []), newInboxItem];
      await set(ref(database, `inbox/${otherUser}`), otherUserInbox);

      // Move to next question in Firebase
      await set(ref(database, `questionIndex/${currentUser}`), questionIndex[currentUser] + 1);
    } catch (error) {
      console.error('Error answering question:', error);
    }
  };

  const skipQuestion = async () => {
    try {
      // Move to next question without answering in Firebase
      await set(ref(database, `questionIndex/${currentUser}`), questionIndex[currentUser] + 1);
    } catch (error) {
      console.error('Error skipping question:', error);
    }
  };

  const answerInboxQuestion = async (inboxItem, answer) => {
    try {
      // Remove from inbox in Firebase (handle null from Firebase)
      const updatedInbox = (inbox[currentUser] || []).filter(item => item.questionId !== inboxItem.questionId);
      await set(ref(database, `inbox/${currentUser}`), updatedInbox);

      // Create answer object for both users
      const answerObj = {
        questionId: inboxItem.questionId,
        questionText: inboxItem.questionText,
        joshAnswer: currentUser === 'josh' ? answer : inboxItem.otherUserAnswer,
        niniAnswer: currentUser === 'nini' ? answer : inboxItem.otherUserAnswer,
        messages: [] // Chat messages go here
      };

      // Add to both users' answers in Firebase (handle null from Firebase)
      const updatedJoshAnswers = [...(answers.josh || []), answerObj];
      const updatedNiniAnswers = [...(answers.nini || []), answerObj];

      await set(ref(database, 'answers/josh'), updatedJoshAnswers);
      await set(ref(database, 'answers/nini'), updatedNiniAnswers);
    } catch (error) {
      console.error('Error answering inbox question:', error);
    }
  };

  const sendMessage = async (questionId, message) => {
    try {
      const newMessage = { user: currentUser, text: message, timestamp: Date.now() };

      // Update answers for both users in Firebase (handle null from Firebase)
      const updatedJoshAnswers = (answers.josh || []).map(item =>
        item.questionId === questionId
          ? { ...item, messages: [...(item.messages || []), newMessage] }
          : item
      );
      const updatedNiniAnswers = (answers.nini || []).map(item =>
        item.questionId === questionId
          ? { ...item, messages: [...(item.messages || []), newMessage] }
          : item
      );

      await set(ref(database, 'answers/josh'), updatedJoshAnswers);
      await set(ref(database, 'answers/nini'), updatedNiniAnswers);

      // Mark as viewed for the sender so they don't see their own message as "new"
      const answer = (currentUser === 'josh' ? updatedJoshAnswers : updatedNiniAnswers)
        .find(a => a.questionId === questionId);

      if (answer) {
        const messageCount = answer.messages?.length || 0;
        const updatedViewedStatus = {
          ...(viewedStatus[currentUser] || {}),
          [questionId]: {
            lastViewed: Date.now(),
            lastMessageCount: messageCount
          }
        };
        await set(ref(database, `viewedStatus/${currentUser}`), updatedViewedStatus);
      }
    } catch (error) {
      console.error('Error sending message:', error);
    }
  };

  const getCurrentQuestion = () => {
    if (!currentUser || !questionIndex) {
      return null;
    }
    const index = questionIndex[currentUser];
    if (index === undefined || index >= questionsPool.length) {
      // If we're at the end but generating more, return a loading indicator
      // Otherwise return null (shouldn't happen with infinite generation, but safety check)
      return isGeneratingMore ? { id: 'loading', type: 'loading', text: 'Generating more questions...' } : null;
    }
    return questionsPool[index];
  };

  const markAnswerAsViewed = async (questionId) => {
    if (!currentUser) {
      console.log('markAnswerAsViewed: no currentUser');
      return;
    }

    try {
      // Find the answer to get the current message count
      const answer = answers[currentUser]?.find(a => a.questionId === questionId);
      if (!answer) {
        console.log('markAnswerAsViewed: answer not found for questionId:', questionId);
        return;
      }

      const messageCount = answer.messages?.length || 0;

      // Update viewed status in Firebase
      const updatedViewedStatus = {
        ...(viewedStatus[currentUser] || {}),
        [questionId]: {
          lastViewed: Date.now(),
          lastMessageCount: messageCount
        }
      };

      console.log('Marking answer as viewed:', questionId, 'messageCount:', messageCount);
      await set(ref(database, `viewedStatus/${currentUser}`), updatedViewedStatus);
      console.log('Successfully marked as viewed');
    } catch (error) {
      console.error('Error marking answer as viewed:', error);
    }
  };

  const value = {
    currentUser,
    currentPage,
    selectUser,
    switchPage,
    startApp,
    questionsPool,
    questionsLoading,
    isGeneratingMore,
    questionIndex,
    inbox,
    answers,
    viewedStatus,
    answerQuestion,
    skipQuestion,
    answerInboxQuestion,
    sendMessage,
    getCurrentQuestion,
    markAnswerAsViewed
  };

  return <AppContext.Provider value={value}>{children}</AppContext.Provider>;
};
