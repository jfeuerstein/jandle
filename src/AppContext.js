import React, { createContext, useContext, useState, useEffect } from 'react';
import { database } from './firebase';
import { ref, set, get, onValue } from 'firebase/database';
import { generateQuestions } from './services/groqService';

const AppContext = createContext();

export const useApp = () => {
  const context = useContext(AppContext);
  if (!context) {
    throw new Error('useApp must be used within AppProvider');
  }
  return context;
};

// Fallback questions if LLM generation fails
const FALLBACK_QUESTIONS = [
  { id: 1, type: 'long_form', text: 'what is your earliest childhood memory?' },
  { id: 2, type: 'long_form', text: 'if you could have dinner with anyone dead or alive, who would it be?' },
  { id: 3, type: 'yes_no', text: 'do you believe in love at first sight?' },
  { id: 4, type: 'multiple_choice', text: 'how do you prefer to spend your free time?', options: ['reading or learning', 'being active or outdoors', 'socializing with friends', 'relaxing at home'] },
];

export const AppProvider = ({ children }) => {
  const [currentUser, setCurrentUser] = useState(null); // 'josh' or 'nini'
  const [currentPage, setCurrentPage] = useState('select'); // 'select', 'questions', 'inbox', 'answers'

  // Questions pool - dynamically generated by LLM
  const [questionsPool, setQuestionsPool] = useState([]);
  const [questionsLoading, setQuestionsLoading] = useState(true);
  const [isGeneratingMore, setIsGeneratingMore] = useState(false);

  // Track current question index for each user
  const [questionIndex, setQuestionIndex] = useState({ josh: 0, nini: 0 });

  // Inbox: questions answered by the other user that this user needs to answer
  // Format: { josh: [{questionId, questionText, otherUserAnswer}], nini: [...] }
  const [inbox, setInbox] = useState({ josh: [], nini: [] });

  // Answers: completed question pairs with chat threads
  // Format: { josh: [{questionId, questionText, joshAnswer, niniAnswer, messages: []}], nini: [...] }
  const [answers, setAnswers] = useState({ josh: [], nini: [] });

  // Generate questions on mount using LLM
  useEffect(() => {
    const loadQuestions = async () => {
      try {
        console.log('Generating questions with Groq LLM...');
        const generatedQuestions = await generateQuestions(10);
        setQuestionsPool(generatedQuestions);
        console.log(`Successfully generated ${generatedQuestions.length} questions`);
      } catch (error) {
        console.error('Failed to generate questions with LLM, using fallback questions:', error);
        setQuestionsPool(FALLBACK_QUESTIONS);
      } finally {
        setQuestionsLoading(false);
      }
    };

    loadQuestions();
  }, []);

  // Monitor question pool and generate more when running low
  useEffect(() => {
    const generateMoreQuestions = async () => {
      // Don't generate if we're already generating or still loading initial questions
      if (isGeneratingMore || questionsLoading || questionsPool.length === 0) {
        return;
      }

      // Find the highest question index across both users
      const maxIndex = Math.max(questionIndex.josh, questionIndex.nini);

      // Trigger generation when within 3 questions of running out
      const threshold = questionsPool.length - 3;

      if (maxIndex >= threshold) {
        setIsGeneratingMore(true);
        try {
          console.log('Running low on questions, generating more...');
          const newQuestions = await generateQuestions(10);
          setQuestionsPool(prevPool => [...prevPool, ...newQuestions]);
          console.log(`Added ${newQuestions.length} new questions. Total: ${questionsPool.length + newQuestions.length}`);
        } catch (error) {
          console.error('Failed to generate more questions:', error);
        } finally {
          setIsGeneratingMore(false);
        }
      }
    };

    generateMoreQuestions();
  }, [questionIndex, questionsPool.length, questionsLoading, isGeneratingMore]);

  // Initialize Firebase data and set up listeners
  useEffect(() => {
    const initializeData = async () => {
      try {
        // Initialize default data structure if it doesn't exist
        const dataRef = ref(database, '/');
        const snapshot = await get(dataRef);

        if (!snapshot.exists()) {
          await set(dataRef, {
            questionIndex: { josh: 0, nini: 0 },
            inbox: { josh: [], nini: [] },
            answers: { josh: [], nini: [] }
          });
        }
      } catch (error) {
        console.error('Error initializing Firebase data:', error);
      }
    };

    initializeData();

    // Set up real-time listeners for data changes
    const questionIndexRef = ref(database, 'questionIndex');
    const inboxRef = ref(database, 'inbox');
    const answersRef = ref(database, 'answers');

    const unsubscribeQuestionIndex = onValue(questionIndexRef, (snapshot) => {
      if (snapshot.exists()) {
        setQuestionIndex(snapshot.val());
      }
    });

    const unsubscribeInbox = onValue(inboxRef, (snapshot) => {
      if (snapshot.exists()) {
        const inboxData = snapshot.val();
        // Ensure inbox values are arrays (Firebase stores empty arrays as null)
        setInbox({
          josh: inboxData.josh || [],
          nini: inboxData.nini || []
        });
      }
    });

    const unsubscribeAnswers = onValue(answersRef, (snapshot) => {
      if (snapshot.exists()) {
        const answersData = snapshot.val();
        // Ensure all answer objects have a messages array
        const normalizedAnswers = {
          josh: (answersData.josh || []).map(answer => ({
            ...answer,
            messages: answer.messages || []
          })),
          nini: (answersData.nini || []).map(answer => ({
            ...answer,
            messages: answer.messages || []
          }))
        };
        setAnswers(normalizedAnswers);
      }
    });

    // Cleanup listeners on unmount
    return () => {
      unsubscribeQuestionIndex();
      unsubscribeInbox();
      unsubscribeAnswers();
    };
  }, []);

  const selectUser = (user) => {
    setCurrentUser(user);
    setCurrentPage('questions');
  };

  const switchPage = (page) => {
    setCurrentPage(page);
  };

  const answerQuestion = async (questionId, questionText, answer, questionType, questionData) => {
    const otherUser = currentUser === 'josh' ? 'nini' : 'josh';

    try {
      // Add to other user's inbox in Firebase with question type data
      // Only include optional properties if they exist (Firebase doesn't allow undefined values)
      const newInboxItem = {
        questionId,
        questionText,
        questionType: questionType || 'long_form',
        otherUserAnswer: answer,
        answeredBy: currentUser
      };

      // Conditionally add optional properties only if they're defined
      if (questionData?.options) {
        newInboxItem.questionOptions = questionData.options;
      }
      if (questionData?.scenario) {
        newInboxItem.questionScenario = questionData.scenario;
      }

      // Firebase stores empty arrays as null, so we need to handle that
      const otherUserInbox = [...(inbox[otherUser] || []), newInboxItem];
      await set(ref(database, `inbox/${otherUser}`), otherUserInbox);

      // Move to next question in Firebase
      await set(ref(database, `questionIndex/${currentUser}`), questionIndex[currentUser] + 1);
    } catch (error) {
      console.error('Error answering question:', error);
    }
  };

  const skipQuestion = async () => {
    try {
      // Move to next question without answering in Firebase
      await set(ref(database, `questionIndex/${currentUser}`), questionIndex[currentUser] + 1);
    } catch (error) {
      console.error('Error skipping question:', error);
    }
  };

  const answerInboxQuestion = async (inboxItem, answer) => {
    try {
      // Remove from inbox in Firebase (handle null from Firebase)
      const updatedInbox = (inbox[currentUser] || []).filter(item => item.questionId !== inboxItem.questionId);
      await set(ref(database, `inbox/${currentUser}`), updatedInbox);

      // Create answer object for both users
      const answerObj = {
        questionId: inboxItem.questionId,
        questionText: inboxItem.questionText,
        joshAnswer: currentUser === 'josh' ? answer : inboxItem.otherUserAnswer,
        niniAnswer: currentUser === 'nini' ? answer : inboxItem.otherUserAnswer,
        messages: [] // Chat messages go here
      };

      // Add to both users' answers in Firebase (handle null from Firebase)
      const updatedJoshAnswers = [...(answers.josh || []), answerObj];
      const updatedNiniAnswers = [...(answers.nini || []), answerObj];

      await set(ref(database, 'answers/josh'), updatedJoshAnswers);
      await set(ref(database, 'answers/nini'), updatedNiniAnswers);
    } catch (error) {
      console.error('Error answering inbox question:', error);
    }
  };

  const sendMessage = async (questionId, message) => {
    try {
      const newMessage = { user: currentUser, text: message, timestamp: Date.now() };

      // Update answers for both users in Firebase (handle null from Firebase)
      const updatedJoshAnswers = (answers.josh || []).map(item =>
        item.questionId === questionId
          ? { ...item, messages: [...(item.messages || []), newMessage] }
          : item
      );
      const updatedNiniAnswers = (answers.nini || []).map(item =>
        item.questionId === questionId
          ? { ...item, messages: [...(item.messages || []), newMessage] }
          : item
      );

      await set(ref(database, 'answers/josh'), updatedJoshAnswers);
      await set(ref(database, 'answers/nini'), updatedNiniAnswers);
    } catch (error) {
      console.error('Error sending message:', error);
    }
  };

  const getCurrentQuestion = () => {
    const index = questionIndex[currentUser];
    if (index >= questionsPool.length) {
      // If we're at the end but generating more, return a loading indicator
      // Otherwise return null (shouldn't happen with infinite generation, but safety check)
      return isGeneratingMore ? { id: 'loading', type: 'loading', text: 'Generating more questions...' } : null;
    }
    return questionsPool[index];
  };

  const value = {
    currentUser,
    currentPage,
    selectUser,
    switchPage,
    questionsPool,
    questionsLoading,
    isGeneratingMore,
    questionIndex,
    inbox,
    answers,
    answerQuestion,
    skipQuestion,
    answerInboxQuestion,
    sendMessage,
    getCurrentQuestion
  };

  return <AppContext.Provider value={value}>{children}</AppContext.Provider>;
};
